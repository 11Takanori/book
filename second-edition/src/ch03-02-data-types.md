## データ型

Rustにおける値は全て、何らかの*型*になり、コンパイラがどんなデータが指定されているか知れるので、
そのデータの取り扱い方も把握できるというわけです。この節では、言語に組み込まれている種々の型について
見ていきましょう。型を二分割しましょう: スカラー型と複合型です。

この節を通して、Rustは*静的型付け*言語であることを弁えておいてください。つまり、コンパイル時に
全ての変数の型が判明している必要があるということです。コンパイラは通常、値と使用方法に基づいて、
使用したい型を推論してくれます。複数の型が推論される可能性がある場合、そう例えば、第2章で`parse`メソッドを
使って`String`型を数値型に変換した時のような場合には、型注釈をつけなければいけません。以下のようにね:

```rust
let guess: u32 = "42".parse().expect("Not a number!");    // 数字ではありません！
```

ここで型注釈を付けなければ、コンパイラは以下のエラーを表示し、これは可能性のある型のうち、
どの型を使用したいのかを知るのに、コンパイラがプログラマからもっと情報を得る必要があることを
意味します:

```text
error[E0282]: unable to infer enough type information about `_`
              (`_`型に関して十分な情報を推論できませんでした)
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^ cannot infer type for `_`
  |               (`_`の型が推論できません)
  |
  = note: type annotations or generic parameter binding required
    (注釈: 型注釈、またはジェネリクス引数束縛が必要です)
```

いろいろなデータ型について議論するにつれて、様々な型注釈を目撃することになるでしょう。

### スカラー型

スカラー型は、単独の値を表します。Rustには主に4つのスカラー型があります:
整数、浮動小数点数、論理値、最後に文字です。他のプログラミング言語でも、これらの型を見かけたことはあるでしょうが、
Rustでの動作方法について見ていきましょう。

#### 整数型

整数とは、小数部分のない数値のことです。この章の前半で一つの整数型を使用しました。`i32`型です。
この型定義は、紐付けられる値が、符号付き整数(そのため、`i`になります。非負整数に対する`u`と逆ですね)
になり、これは、32ビット分のサイズを取ります。表3-1は、Rustの組み込み整数型を表示しています。
符号付きと符号なし欄の各バリアント(例: *i32*)を使用して、整数値の型を定義することができます。

<span class="caption">表3-1: Rustの整数型</span>

| 大きさ | 符号付き | 符号なし |
|--------|--------|----------|
| 8-bit  | i8     | u8       |
| 16-bit | i16    | u16      |
| 32-bit | i32    | u32      |
| 64-bit | i64    | u64      |
| arch   | isize  | usize    |

各バリアントは、符号付きか符号なしかを選べ、明示的なサイズを持ちます。符号付きと符号なしの特性は、
数値が正負を持つかどうかを示します。つまり、数値が符号を持つ必要があるかどうか(符号付き)、または、
絶対に正数にしかならず符号なしで表現できるかどうか(符号なし)です。これは、数値を紙に書き下すのと似ています:
符号が問題になるなら、数値はプラス記号、またはマイナス記号とともに表示されます; しかしながら、
その数値が正数であると仮定することが安全なら、符号なしで表示できるわけです。符号付き数値は、
2の補数表現で保持されます(これが何なのか確信を持てないのであれば、ネットで検索することができます。
まあ要するに、この解説は、この本の範疇外というわけです)。

各符号付きバリアントは、-(2<sup>n - 1</sup>)から2<sup>n - 1</sup> - 1までの数値を保持でき、
ここで`n`はこのバリアントが使用するビット数です。以上から、`i8`型は-(2<sup>7</sup>)から
2<sup>7</sup> - 1まで、つまり、-128から127までを保持できます。符号なしバリアントは、0から
2<sup>n</sup> - 1までを保持できるので、`u8`型は、0から2<sup>8</sup> - 1までの値、つまり、
0から255までを保持できることになります。

加えて、`isize`と`usize`型は、プログラムが動作しているコンピュータの種類に依存します: 
64ビットアーキテクチャなら、64ビットですし、32ビットアーキテクチャなら、32ビットになります。

整数リテラル(`脚注`: リテラルとは、見たまんまの値ということ)は表3-2に示すどの形態でも記述することができます。バイトリテラルを除く数値リテラルは全て、
型接尾辞を付加すること(例えば、`57u8`)と`_`を見た目の区切り記号(例えば、`1_000`)にできます。

<span class="caption">表3-2: Rustの整数リテラル</span>

| 数値リテラル       | 例       |
|------------------|---------------|
| 10進数            | `98_222`      |
| 16進数            | `0xff`        |
| 8進数             | `0o77`        |
| 2進数             | `0b1111_0000` |
| バイト (`u8`だけ)  | `b'A'`        |

では、どの整数型を使うべきかはどう把握すればいいのでしょうか？もし確信が持てないのならば、Rustの
デフォルトは一般的にいい選択になります。整数型の基準は`i32`型です: 64ビットシステム上でも、
普通最速になります。`isize`と`usize`を使う主な状況は、何らかのコレクションにアクセスすることです。

#### 浮動小数点型

Rustにはさらに、*浮動小数点数*に対しても、2種類の基本型があり、浮動小数点数とは10進小数のことです。
Rustの浮動小数点型は、`f32`と`f64`で、それぞれ32ビットと64ビットサイズです。基準型は`f64`です。
なぜなら、`f32`とほぼ同スピードにもかかわらず、より精度が高くなるからです。32ビットシステム上でも、
`f64`型を使用することはできますが、`f32`型を使うよりも遅くなります。ほとんどの場合、パフォーマンスが悪くなる
可能性と引き換えに高精度を得ることは、一考の価値のある第1選択肢になる上、自らのコードで浮動小数点数のサイズが
問題になる可能性があると疑うのなら、ベンチマークをしてみるべきです。

実際に動作している浮動小数点数の例をご覧ください:

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```

浮動小数点数は、IEEE-754規格に従って表現されています。`f32`が単精度浮動小数点数、
`f64`が倍精度浮動小数点数です。

#### 数値演算

Rustにも期待されうる標準的な数学演算が全数値型に対して用意されています: 足し算、引き算、掛け算、割り算、余りです。
以下の例では、`let`文での各演算の使用方法をご覧になれます:

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    // 足し算
    let sum = 5 + 10;

    // 引き算
    let difference = 95.5 - 4.3;

    // 掛け算
    let product = 4 * 30;

    // 割り算
    let quotient = 56.7 / 32.2;

    // 余り
    let remainder = 43 % 5;
}
```

これらの文の各式は、数学演算子を使用しており、一つの値に評価され、変数に束縛されます。付録BにRustで使える
演算子の一覧が載っています。

#### 論理値型

他の多くの言語同様、Rustの論理値型も取りうる値は二つしかありません: `true`と`false`です。
Rustの論理値型は、`bool`と指定されます。
例です:

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    let t = true;

    let f: bool = false; // 明示的型注釈付きで
}
```

論理値を消費する主な手段は、条件式です。例えば、`if`式などですね。`if`式の動作方法については、
「フロー制御」節で解説します。

#### 文字型

ここまで、数値型のみ扱ってきましたが、Rustには文字も用意されています。Rustの`char`型は、言語の最も
基本的なアルファベット型であり、以下のコードでその使用方法の一例を見ることができます:

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
   let c = 'z';
   let z = 'ℤ';
   let heart_eyed_cat = '😻';    //ハート目の猫
}
```

Rustの`char`型は、ユニコードのスカラー値を表します。これはつまり、アスキーよりもずっとたくさんの
ものを表せるということです。アクセント文字、中国語/日本語/韓国語表意文字(`脚注`: 漢字のことだと思われる)、
絵文字、ゼロ幅スペースは、全てRustでは、有効な`char`型になります。ユニコードスカラー値は、
`U+0000`から`U+D7FF`までと`U+E0000`から`U+10FFFF`までの範囲になります。ところが、「文字」は
実はユニコードの概念ではないので、文字とは何かという人間としての直観は、Rustにおける`char`型が何か
とは合致しない可能性があります。この話題については第8章の「文字列」節で詳しく議論しましょう。

### 複合型

*複合型*により、複数の型の値を一つの型にまとめることができます。Rustには、
2種類の基本的な複合型があります: タプルと配列です。

#### 値をタプルにまとめ上げる

タプルは、複数の型の何らかの値を一つの複合型にまとめ上げる一般的な手段です。

タプルは、丸かっこの中にカンマ区切りの値リストを書くことで生成します。タプルの各位置には型が紐付けられ、
タプルの値は全てが同じ型である必要はありません。今回の例では、型注釈をあえて追加してみました:

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

変数`tup`は、タプル全体に束縛されています。なぜなら、タプルは、一つの複合要素と考えられるからです。
タプルからここの値を取り出すには、パターンマッチングにより分解を使用することができます。以下のように:

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```

このプログラムは、まずタプルを生成し、それを変数`tup`に束縛しています。それから`let`文と
パターンを使って`tup`変数の中身を3つの個別の変数(`x`、`y`、`z`ですね)に変換しています。
この過程は、*分解*と呼ばれます。単独のタプルを破壊して三分割しているからです。最後に、
プログラムは`y`変数の値を出力し、それは`6.4`になります。

パターンマッチングを通しての分解の他にも、アクセスしたい値の番号をピリオドに続けて書くことで、
タプルの要素に直接アクセスすることもできます。例です:

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```

このプログラムは、新しいタプル`x`を作成し、添え字アクセスで書く要素に対して新しい変数も作成しています。
多くのプログラミング言語同様、タプルの最初の添え字は0です。

#### 配列

*配列*によっても、複数の値のコレクションを得ることができます。タプルと異なり、配列の全要素は、
同じ型でなければなりません。Rustの配列は、他の言語と異なっている場合があります。Rustの配列は、
固定長なのです: 一度定義されたら、サイズを伸ばすことも縮めることもできません。

Rustでは、配列に入れる要素は、角かっこ内にカンマ区切りリストとして記述します:

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

配列は、ヒープよりもスタック(スタックとヒープについては第4章で詳らかに議論します)にデータのメモリを確保したい時、
または、常に固定長の要素があることを確認したい時に便利です。ただ、配列は、ベクタ型ほどは柔軟ではありません。
ベクタ型も、標準ライブラリによって提供されている似たようなコレクション型で、こちらは、
サイズを伸縮させることが*できます*。配列とベクタ型、どちらを使うべきか確信が持てない時は、
おそらくベクタ型を使うべきです: 第8章でベクタ型について詳細に議論します。

ベクタ型よりも配列を使いたくなる例は、1年の月の名前を扱うプログラムです。そのようなプログラムで、
月を追加したり削除したりすることはほぼ稀なので、配列を使用できます。常に12個要素があることも自明ですしね:

```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```

##### 配列の要素にアクセスする

配列は、スタック上に確保される一塊のメモリです。添え字によって配列の
要素にアクセスすることができます。こんな感じ:

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```

この例では、`first`という名前の変数には`1`という値が格納されます。配列の`[0]`番目にある値が
それだからですね。`second`という名前の変数には、配列の`[1]`番目の値`2`が格納されます。

##### 配列要素への無効なアクセス

配列の終端を越えて要素にアクセスしようとしたら、どうなるだろうか？先ほどの例を以下のように
変えたとしよう:

<span class="filename">ファイル名: src/main.rs</span>

```rust,ignore
fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!("The value of element is: {}", element);   // 要素の値は{}です
}
```

このコードを`cargo run`で走らせると、以下のような結果になります:

```text
$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
     Running `target/debug/arrays`
thread '<main>' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:6
スレッド'<main>'は'範囲外アクセス: 長さは5ですが、添え字は10でした', src/main.rs:6
でパニックしました
note: Run with `RUST_BACKTRACE=1` for a backtrace.
```

コンパイルでは何もエラーが出なかったものの、プログラムは*実行時*エラーに陥り、
正常終了しませんでした。要素に添え字アクセスを試みると、言語は、指定されたその添え字が
配列長よりも小さいかをチェックしてくれます。添え字が配列長よりも大きければ、言語は*パニック*します。
パニックとは、プログラムがエラーで終了したことを表すRust用語です。

これは、実際に稼働しているRustの安全機構の最初の例になります。低レベル言語の多くでは、
この種のチェックは行われないため、間違った添え字を与えると、無効なメモリにアクセスできてしまいます。
Rustでは、メモリアクセスを許可し、処理を継続する代わりに即座にプログラムを終了することで
この種のエラーからプログラマを保護しています。Rustのエラー処理については、第9章で詳しく議論します。
