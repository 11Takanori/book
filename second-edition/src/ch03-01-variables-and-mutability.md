## 変数と可変性

第2章で触れた通り、変数は標準で*不変*になります。これは、Rustが提供する安全性や簡潔な並列プログラミングの
利点を享受する形でコードを書くことを推奨してくれる一押しです。ところが、まだ変数を可変にするという
選択肢も残されています。不変性を好むようコンパイラが推奨する手段と理由および、それと違う道を選びたくなる理由を
見ていきましょう。

変数が不変であるとは、値が一旦名前に束縛されたら、その値を変えることができないことを意味します。
具体化するために、*projects*ディレクトリに`cargo new --bin variables`コマンドを使って
*variables*という名前のプロジェクトを生成しましょう。

それから、新規作成した*variables*ディレクトリで、*src/main.rs*ファイルを開き、その中身を以下のように置き換えましょう:

<span class="filename">ファイル名: src/main.rs</span>

```rust,ignore
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);     // xの値は{}です
    x = 6;
    println!("The value of x is: {}", x);
}
```

これを保存し、`cargo run`コマンドでプログラムを走らせてください。次の出力に示されているようなエラーメッセージを受け取るはずです:

```text
error[E0384]: re-assignment of immutable variable `x`
              (不変変数`x`への再代入)
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
  |         (`x`への最初の代入)
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ re-assignment of immutable variable
```

この例では、コンパイラがプログラムに潜むエラーを見つけ出す手助けをしてくれることが示されています。
コンパイルエラーは、イライラするものですが、まだプログラムにしてほしいことを安全に行えていないだけ
なのです; エラーが出るからといって、あなたがいいプログラマではないという意味では*ありません*！
経験豊富なRust市民でも、コンパイラエラーを出すことはあります。このエラーは、エラーの原因が
`不変変数への再代入`であると示しています。不変な`x`という変数に第2段階の値を代入しようとしたからです。

以前に不変と指定された値を変えようとした時に、コンパイルエラーが出るのは重要なことです。
なぜなら、この状況はまさしく、バグに繋がるからです。コードのある部分は、値が変わることはないという
前提のもとに処理を行い、別の部分がその値を変更していたら、最初の部分が目論見通りに
動いていない可能性があるのです。このようなバグの発生は、事実(`脚注`:実際にプログラムを走らせた結果のことと思われる)
の後には追いかけづらいものです。特に第2のコード破片が、値を*時々*しか変えない場合尚更です。

Rustでは、値が不変であると宣言したら、本当に変わらないことをコンパイラが担保してくれます。
つまり、コードを読み書きする際に、どこでどうやって値が変化しているかを追いかける必要がなくなり、
コードが行うことを把握しやすくなります。

しかし、可変性は時として非常に便利なこともあります。変数は、標準でのみ、不変です。つまり、変数名の前に
`mut`キーワードを付ければ、可変にできるわけです。 この値が変化できるようにするとともに、未来の読者に対して
コードの別の部分がこの変数の値を変えることを示すことで、その意図を汲ませることができるのです。

例として、*src/main.rs*ファイルを以下のように書き換えてください:

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

このプログラムを走らせると、以下のような出力が得られます:

```text
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
     Running `target/debug/variables`
The value of x is: 5   (xの値は5です)
The value of x is: 6
```

`mut`キーワードを使うことで、`x`が束縛している値を`5`から`6`に変更できるようになりました。
変数を可変にする方が、不変変数だけを使う実装よりも書きやすくなるケースもあるでしょう。

考えるべきトレードオフはバグの阻止以外にも、いくつかあります。例えば、大きなデータ構造を使う場合などです。
オブジェクトを可変にして変更できるようにする方が、いちいちオブジェクトをコピーして新しくメモリ割り当てされた
オブジェクトを返すよりも速くなります。小規模なデータ構造なら、新規オブジェクトを生成して、
もっと関数型っぽいコードを書く方が中身を把握しやすくなるため、低パフォーマンスは、その簡潔性を得るのに
足りうるペナルティになるかもしれません。

### 変数と定数(constants)の違い

変数の値を変更できないようにするといえば、他の多くの言語も持っている別のプログラミング概念を思い浮かべるでしょう:
*定数*です. 不変変数のように、定数も名前に紐付き、変更することが叶わない値のことですが、
定数と変数の間にはいくつかの違いがあります。

まず、定数には`mut`キーワードは使えません: 定数は標準で不変であるだけでなく、常に不変なのです。

定数は`let`キーワードの代わりに、`const`キーワードで宣言し、値の型は*必ず*注釈しなければなりません。
型と型注釈については次のセクション、「データ型」で解説する予定なので、その詳細については気にする必要はありません。
ただ単に型を注釈しなければならないのだと思っていてください。

定数はどんなスコープでも定義できます。グローバルスコープも含めてね。なので、いろんなところで使用される可能性のある値を
定義するのに便利です。

最後の違いは、定数は定数式にしかセットできないことです。関数呼び出し結果や、実行時に評価される値ではありません。

定数の名前が`MAX_POINTS`で値が100,000にセットされた定数定義の例をご覧ください。(Rustの定数の命名規則は、
全て大文字でアンダースコアで単語区切りすることです):

```rust
const MAX_POINTS: u32 = 100_000;
```

定数は、プログラムが走る期間、定義されたスコープ内でずっと有効です。従って、プログラムのいろんなところで
使用される可能性のあるアプリケーション空間の値を定義するのに便利な選択肢になります。例えば、ゲームでプレイヤーが取得可能なポイントの
最高値や、光速度などですね。

プログラム中で使用されるハードコードされた値に対して、定数として名前付けすることは、コードの将来的な
管理者にとって値の意味を汲むのに便利です。将来、ハードコードされた値を変える必要が出た時に、
たった1箇所を変更するだけで済むようにもしてくれる。

### (変数の)多重定義

第2章の数当てゲームのチュートリアルで見たように、前に定義した変数と同じ名前の変数を新しく定義でき、
新しい変数は、前の変数を*上書き*(shadow)する。Rust市民はこれを最初の変数は、2番目の変数に*上書き*
されたと言い、この変数を使用した際に、2番目の変数の値が得られるということです。
以下のようにして、同じ変数名を用いて変数を上書きし、`let`キーワードの使用を繰り返します:

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!("The value of x is: {}", x);
}
```

このプログラムはまず、`x`を`5`という値に束縛します。それから`let x =`という文法要素を繰り返すことで
`x`を上書きし、元の値に`1`を加えることになるので、`x`の値は、`6`になります。
3番目の`let`文も`x`を上書きし、以前の値に`2`をかけることになるので、`x`の最終的な値は`12`になります。
このプログラムを走らせたら、以下のように出力するでしょう:

```text
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
     Running `target/debug/variables`
The value of x is: 12
```

これは、変数を`mut`にするのとは違います。なぜなら、`let`キーワードを使っている限り、誤ってこの変数に
再代入を試みようものなら、コンパイルエラーが出るからです。値にちょっとした加工は加えられますが、
その加工が終わったら、変数は不変になるわけです。

`mut`と上書きの別の違いは、再度`let`キーワードを使用したら、実効的には新しい変数を生成していることになるので、
値の型を変えつつ、同じ変数名を使いまわせることです。例えば、プログラムがユーザに何らかのテキストに対して
空白文字を入力することで何個分のスペースを表示したいかを尋ねるとします。ただ、この入力を数値として
保持したいとしましょう:

```rust
let spaces = "   ";
let spaces = spaces.len();
```

この文法要素は、容認されます。というのも、最初の`spaces`変数は文字列型であり、2番目の`spaces`変数は、
たまたま最初の変数と同じ名前になったまっさらな変数のわけですが、数値型になるからです。故に、多重定義のおかげで、
異なる名前を思いつく必要がなくなるわけです。`spaces_str`と`spaces_num`などですね; 代わりに、
よりシンプルな`spaces`という名前を再利用できるわけです。一方で、この場合に`mut`を使おうとすると、
以下に示した通りですが:

```rust,ignore
let mut spaces = "   ";
spaces = spaces.len();
```

コンパイルエラーが発生します。変数の型を可変にすることは許されていないからですね:

```text
error[E0308]: mismatched types          (型が合いません)
 --> src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected &str, found usize
  |                           (&str型を予期しましたが、usizeが見つかりました)
  |
  = note: expected type `&str`
             found type `usize`
```

さあ、変数が動作する方法を見てきたので、今度は変数が取りうるデータ型について見ていきましょう。
